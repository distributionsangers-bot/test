-- ============================================
-- FIX: Capture du statut bénévole-école à l'inscription
-- ============================================
-- Problème: Un bénévole peut changer son statut mandatory_hours entre
-- l'inscription et le check-in pour contourner les règles de validation.
--
-- Solution: Enregistrer le statut au moment de l'inscription dans une
-- nouvelle colonne `was_school_volunteer` qui sera utilisée pour le calcul.
-- ============================================

-- 1. Ajouter la colonne à registrations
ALTER TABLE public.registrations 
ADD COLUMN IF NOT EXISTS was_school_volunteer boolean DEFAULT NULL;

-- 2. Mettre à jour register_to_shift pour capturer le statut
DROP FUNCTION IF EXISTS public.register_to_shift(bigint);
DROP FUNCTION IF EXISTS public.register_to_shift(bigint, text);
DROP FUNCTION IF EXISTS public.register_to_shift(uuid);
DROP FUNCTION IF EXISTS public.register_to_shift(uuid, text);

CREATE OR REPLACE FUNCTION public.register_to_shift(p_shift_id BIGINT, p_note TEXT DEFAULT NULL)
RETURNS VOID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_user_id UUID;
    v_max_slots INT;
    v_current_count INT;
    v_start_time TIME;
    v_end_time TIME;
    v_event_date DATE;
    v_conflict_count INT;
    v_is_school_volunteer BOOLEAN;
    v_reserved_slots INT;
    v_current_reserved_taken INT;
BEGIN
    v_user_id := auth.uid();

    -- Check if shift exists and get details
    SELECT max_slots, start_time, end_time, events.date, reserved_slots, COALESCE(reserved_taken, 0)
    INTO v_max_slots, v_start_time, v_end_time, v_event_date, v_reserved_slots, v_current_reserved_taken
    FROM shifts
    JOIN events ON shifts.event_id = events.id
    WHERE shifts.id = p_shift_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Shift not found';
    END IF;

    -- Check if user is a school volunteer (capture at registration time!)
    SELECT COALESCE(mandatory_hours, FALSE)
    INTO v_is_school_volunteer
    FROM profiles
    WHERE id = v_user_id;

    -- Check for conflicts (same date, overlapping time)
    SELECT count(*)
    INTO v_conflict_count
    FROM registrations r
    JOIN shifts s ON r.shift_id = s.id
    JOIN events e ON s.event_id = e.id
    WHERE r.user_id = v_user_id
        AND e.date = v_event_date
        AND r.shift_id != p_shift_id
        AND (
            (s.start_time, s.end_time) OVERLAPS (v_start_time, v_end_time)
        );

    IF v_conflict_count > 0 THEN
        RAISE EXCEPTION 'Time conflict with another registration today';
    END IF;

    -- Check capacity (Locking for concurrency)
    LOCK TABLE registrations IN EXCLUSIVE MODE;

    SELECT count(*)
    INTO v_current_count
    FROM registrations
    WHERE shift_id = p_shift_id;

    IF v_current_count >= v_max_slots THEN
        RAISE EXCEPTION 'Shift is full';
    END IF;

    -- Insert registration with note AND was_school_volunteer status
    INSERT INTO registrations (user_id, shift_id, note, was_school_volunteer)
    VALUES (v_user_id, p_shift_id, p_note, v_is_school_volunteer);

    -- Update total_registrations counter
    UPDATE shifts 
    SET total_registrations = v_current_count + 1
    WHERE id = p_shift_id;

    -- If school volunteer and reserved slots available, increment reserved_taken
    IF v_is_school_volunteer AND v_reserved_slots > 0 AND v_current_reserved_taken < v_reserved_slots THEN
        UPDATE shifts 
        SET reserved_taken = v_current_reserved_taken + 1
        WHERE id = p_shift_id;
    END IF;

END;
$$;

-- 3. Mettre à jour toggle_attendance pour utiliser was_school_volunteer
CREATE OR REPLACE FUNCTION public.toggle_attendance(p_reg_id bigint, p_is_present boolean)
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_reg RECORD;
    v_shift RECORD;
    v_hours NUMERIC;
    v_should_count BOOLEAN;
    v_old_counted NUMERIC;
    v_new_counted NUMERIC;
    v_is_school_volunteer BOOLEAN;
    v_registration_order INT;
    v_reserved_slots INT;
BEGIN
    -- Get Registration
    SELECT * INTO v_reg FROM public.registrations WHERE id = p_reg_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Registration not found';
    END IF;

    -- Get Shift
    SELECT * INTO v_shift FROM public.shifts WHERE id = v_reg.shift_id;
    
    -- Use the captured status from registration time!
    -- Fallback to current profile if was_school_volunteer is NULL (old data)
    IF v_reg.was_school_volunteer IS NOT NULL THEN
        v_is_school_volunteer := v_reg.was_school_volunteer;
    ELSE
        -- Fallback for old registrations without this field
        SELECT COALESCE(mandatory_hours, FALSE) INTO v_is_school_volunteer
        FROM public.profiles WHERE id = v_reg.user_id;
    END IF;
    
    -- Get reserved slots for this shift
    v_reserved_slots := COALESCE(v_shift.reserved_slots, 0);

    -- Determine if this volunteer should count for hours
    IF v_is_school_volunteer AND v_reserved_slots > 0 THEN
        -- Count how many school volunteers registered BEFORE this one on this shift
        -- Use was_school_volunteer if available, otherwise fallback
        SELECT COUNT(*) INTO v_registration_order
        FROM public.registrations r
        WHERE r.shift_id = v_reg.shift_id
          AND (
              (r.was_school_volunteer = TRUE) OR 
              (r.was_school_volunteer IS NULL AND EXISTS (
                  SELECT 1 FROM public.profiles p 
                  WHERE p.id = r.user_id AND p.mandatory_hours = TRUE
              ))
          )
          AND r.created_at < v_reg.created_at;
        
        -- If their position is within reserved slots, they count
        v_should_count := (v_registration_order < v_reserved_slots);
    ELSIF v_is_school_volunteer AND v_reserved_slots = 0 THEN
        -- School volunteer on a shift with NO reserved slots = never counts
        v_should_count := FALSE;
    ELSE
        -- Non-school volunteer: always counts
        v_should_count := TRUE;
    END IF;

    -- Update the counts_for_hours field based on our calculation
    -- IMPORTANT: Never downgrade from TRUE to FALSE (respects admin "Force Validation")
    IF v_reg.counts_for_hours = FALSE AND v_should_count = TRUE THEN
        UPDATE public.registrations 
        SET counts_for_hours = TRUE
        WHERE id = p_reg_id;
    END IF;
    
    -- Re-fetch to get the potentially updated value
    SELECT counts_for_hours INTO v_should_count FROM public.registrations WHERE id = p_reg_id;

    -- Update Attended status
    UPDATE public.registrations 
    SET attended = p_is_present,
        checked_in_at = CASE WHEN p_is_present THEN NOW() ELSE NULL END
    WHERE id = p_reg_id;

    -- Handle Hours
    v_hours := COALESCE(v_shift.hours_value, 0);
    v_old_counted := COALESCE(v_reg.hours_counted, 0);
    v_new_counted := 0;

    -- Calculate what the new hours_counted SHOULD be
    IF p_is_present AND v_should_count THEN
        v_new_counted := v_hours;
    END IF;

    -- Update Profile total_hours
    IF v_new_counted <> v_old_counted THEN
        UPDATE public.profiles
        SET total_hours = COALESCE(total_hours, 0) - v_old_counted + v_new_counted
        WHERE id = v_reg.user_id;

        -- Update Registration history
        UPDATE public.registrations
        SET hours_counted = v_new_counted
        WHERE id = p_reg_id;
    END IF;

    RETURN jsonb_build_object(
        'success', true,
        'counts_for_hours', v_should_count,
        'hours_counted', v_new_counted
    );
END;
$$;

-- 4. Backfill des inscriptions existantes
-- Met à jour was_school_volunteer pour les inscriptions existantes
UPDATE registrations r
SET was_school_volunteer = (
    SELECT COALESCE(p.mandatory_hours, FALSE)
    FROM profiles p
    WHERE p.id = r.user_id
)
WHERE r.was_school_volunteer IS NULL;

-- 5. RECALCUL des compteurs pour TOUTES les données existantes
-- ============================================

-- 5a. Recalculer total_registrations pour TOUS les créneaux
UPDATE shifts s
SET total_registrations = (
    SELECT COUNT(*)
    FROM registrations r
    WHERE r.shift_id = s.id
);

-- 5b. Recalculer reserved_taken pour les créneaux avec places réservées
-- Compte les bénévoles école inscrits DANS LA LIMITE des places réservées
UPDATE shifts s
SET reserved_taken = (
    SELECT LEAST(
        COALESCE(s.reserved_slots, 0),
        (
            SELECT COUNT(*)
            FROM registrations r
            WHERE r.shift_id = s.id
              AND (
                  r.was_school_volunteer = TRUE 
                  OR (r.was_school_volunteer IS NULL AND EXISTS (
                      SELECT 1 FROM profiles p 
                      WHERE p.id = r.user_id AND p.mandatory_hours = TRUE
                  ))
              )
        )
    )
)
WHERE s.reserved_slots > 0;

-- Mettre à 0 pour les créneaux sans places réservées
UPDATE shifts SET reserved_taken = 0 WHERE reserved_slots = 0 OR reserved_slots IS NULL;

-- 6. TRIGGER pour gérer les désinscriptions
-- ============================================
CREATE OR REPLACE FUNCTION public.handle_registration_delete()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_is_school_volunteer BOOLEAN;
    v_shift RECORD;
    v_school_volunteers_count INT;
    v_new_reserved_taken INT;
BEGIN
    -- Get shift details
    SELECT * INTO v_shift FROM shifts WHERE id = OLD.shift_id;
    
    -- Check if the deleted user was a school volunteer
    -- Use was_school_volunteer if available
    IF OLD.was_school_volunteer IS NOT NULL THEN
        v_is_school_volunteer := OLD.was_school_volunteer;
    ELSE
        SELECT COALESCE(mandatory_hours, FALSE)
        INTO v_is_school_volunteer
        FROM profiles
        WHERE id = OLD.user_id;
    END IF;

    -- Decrement total_registrations
    UPDATE shifts 
    SET total_registrations = GREATEST(0, COALESCE(total_registrations, 0) - 1)
    WHERE id = OLD.shift_id;

    -- If school volunteer and there were reserved slots, recalculate reserved_taken
    IF v_is_school_volunteer AND COALESCE(v_shift.reserved_slots, 0) > 0 THEN
        -- Count remaining school volunteers on this shift
        SELECT COUNT(*) INTO v_school_volunteers_count
        FROM registrations r
        WHERE r.shift_id = OLD.shift_id
          AND r.id != OLD.id  -- Exclude the one being deleted
          AND (
              r.was_school_volunteer = TRUE 
              OR (r.was_school_volunteer IS NULL AND EXISTS (
                  SELECT 1 FROM profiles p 
                  WHERE p.id = r.user_id AND p.mandatory_hours = TRUE
              ))
          );
        
        -- reserved_taken = MIN(school_volunteers_count, reserved_slots)
        v_new_reserved_taken := LEAST(v_school_volunteers_count, v_shift.reserved_slots);
        
        UPDATE shifts 
        SET reserved_taken = v_new_reserved_taken
        WHERE id = OLD.shift_id;
    END IF;

    RETURN OLD;
END;
$$;

-- Drop existing trigger if exists and create new one
DROP TRIGGER IF EXISTS on_registration_delete ON registrations;
CREATE TRIGGER on_registration_delete
    AFTER DELETE ON registrations
    FOR EACH ROW
    EXECUTE FUNCTION handle_registration_delete();

-- ============================================
-- RÉSUMÉ:
-- Cette migration complète corrige:
-- 1. La faille de sécurité (was_school_volunteer)
-- 2. Le compteur reserved_taken pour données existantes
-- 3. Le compteur total_registrations pour données existantes
-- 4. Les désinscriptions (trigger on delete)
-- ============================================
